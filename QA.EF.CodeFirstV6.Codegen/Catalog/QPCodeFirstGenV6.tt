<#@ template debug="false" hostspecific="true" language="C#"
#>
<#@output extension=".log"
#><#@ assembly name="System.Core" 
#><#@ assembly name="System.Data" 
#><#@ assembly name="System.Data.Entity" 
#><#@ assembly name="System.Data.Entity.Design" 
#><#@ assembly name="System.Data.Linq"
#><#@ assembly name="EnvDTE"
#><#@ assembly name="System.Xml"
#><#@ assembly name="System.Xml.Linq"
#><#@ import namespace="System"
#><#@ import namespace="System.CodeDom"
#><#@ import namespace="System.CodeDom.Compiler"
#><#@ import namespace="System.Collections.Generic"
#><#@ import namespace="System.Data.Linq"
#><#@ import namespace="System.Data.Linq.Mapping"
#><#@ import namespace="System.IO"
#><#@ import namespace="System.ComponentModel"  
#><#@ import namespace="System.Linq" 
#><#@ import namespace="System.Xml" 
#><#@ import namespace="System.Linq"
#><#@ import namespace="System.Reflection"
#><#@ import namespace="System.Text"
#><#@ import namespace="Microsoft.VisualStudio.TextTemplating"
#><#@ import namespace="System.Xml.Linq"
#><#@ import namespace="System.IO" #><#
	
	var settings = EDMXSettings.Parse(Path.Combine(Path.GetDirectoryName(Host.TemplateFile), "QPCodeFirstGenV6.tt.settings.xml"));
	
	// settings
	bool usePartialUpdate = false;

    var filename = Path.Combine(Path.GetDirectoryName(Host.TemplateFile), settings.QPContextMappingResultPath);

	var model = new ModelReader(filename, text => WriteLine(text), true);

	List<ModelReader> models = new List<ModelReader>();

	model.Schema.LazyLoadingEnabled = settings.LazyLoadingEnabled;
	model.Schema.IsStageMode = true;
	WriteLine("ClassName:  " + model.Schema.ClassName);

	model.Schema.ConnectionStringName = settings.UseContextNameAsConnectionString ? model.Schema.ClassName : model.Schema.ConnectionStringName;
	
	WriteLine("ConnectionStringName:  " + model.Schema.ConnectionStringName);

	var manager = Manager.Create(Host, GenerationEnvironment); 

if(settings.GenerateModel)
{
	manager.StartNewFile(model.Schema.ClassName + ".cs");
#>
namespace <#=System.Runtime.Remoting.Messaging.CallContext.LogicalGetData("NamespaceHint")#>
{
    using System;
    using System.Data.Entity;
    using System.ComponentModel.DataAnnotations.Schema;
    using System.Linq;
	<#= settings.Usings == null #>
	***<#= settings.Usings #>||||

    public partial class <#=model.Schema.ClassName#> : DbContext
    {
        partial void OnContextCreated();

        static <#=model.Schema.ClassName#>()
        {
            Database.SetInitializer<<#= model.Schema.ClassName#>>(new NullDatabaseInitializer<<#=model.Schema.ClassName#>>());
        }

        public <#=model.Schema.ClassName#>()
            : base("name=<#=model.Schema.ConnectionStringName#>")
        {
            this.Configuration.LazyLoadingEnabled = <#=settings.LazyLoadingEnabled.ToString().ToLower()#>;

			OnContextCreated();
        }

        public virtual DbSet<StatusType> StatusTypes { get; set; }
        public virtual DbSet<User> Users { get; set; }
        public virtual DbSet<UserGroup> UserGroups { get; set; }		
<#
		foreach(var content in model.Contents)
		{
#>
        public virtual DbSet<<#=content.MappedName#>> <#=content.PluralMappedName#> { get; set; }
<#
        }
#>
        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            var mapping = new <#=model.Schema.ClassName#>MappingConfigurator();
            mapping.OnModelCreating(modelBuilder);
        }
    }
}
<#}
if (settings.GenerateMappings)
{
manager.StartNewFile(model.Schema.ClassName + "MappingConfigurator.cs");
#>
using System;
using System.Collections.Concurrent;
using System.ComponentModel.DataAnnotations.Schema;
using System.Data.Common;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Threading;
<#= settings.Usings#>

namespace <#=System.Runtime.Remoting.Messaging.CallContext.LogicalGetData("NamespaceHint")#>
{
    public class <#=model.Schema.ClassName#>MappingConfigurator : IMappingConfigurator
    {
	    public static ContentAccess DefaultContentAccess = ContentAccess.Live;
        private ContentAccess _contentAccess;
		private static ConcurrentDictionary<ContentAccess, Lazy<DbCompiledModel>> _cache = new ConcurrentDictionary<ContentAccess, Lazy<DbCompiledModel>>();

        public <#=model.Schema.ClassName#>MappingConfigurator()
            : this(DefaultContentAccess)
        { }


        public <#=model.Schema.ClassName#>MappingConfigurator(ContentAccess contentAccess)
        {
            _contentAccess = contentAccess;
        }

        public virtual DbCompiledModel GetBuiltModel(DbConnection connection)
        {           
            return _cache.GetOrAdd(_contentAccess, a =>
            {
                var builder = new DbModelBuilder();
                OnModelCreating(builder);
                var builtModel = builder.Build(connection);

                return new Lazy<DbCompiledModel>( 
                    () => builtModel.Compile(), 
                    LazyThreadSafetyMode.ExecutionAndPublication);
            }).Value;
        }


        public virtual void OnModelCreating(DbModelBuilder modelBuilder)
        {

            #region StatusType
            modelBuilder.Entity<StatusType>()
                .ToTable("STATUS_TYPE_NEW")
                .Property(x => x.Id)
                .HasDatabaseGeneratedOption(DatabaseGeneratedOption.Identity)
                .HasColumnName("id");

            modelBuilder.Entity<StatusType>().Property(e => e.SiteId).HasColumnName("site_id");
            modelBuilder.Entity<StatusType>().Property(e => e.StatusTypeName).HasColumnName("name");
            modelBuilder.Entity<StatusType>().Property(e => e.Weight).HasColumnName("weight");
            #endregion

            #region User
            modelBuilder.Entity<User>()
                .ToTable("USER_NEW")
                .Property(e => e.Id)
                .HasDatabaseGeneratedOption(DatabaseGeneratedOption.Identity)
                .HasColumnName("id");

            modelBuilder.Entity<User>().Property(e => e.FirstName).HasColumnName("first_name");
            modelBuilder.Entity<User>().Property(e => e.LastName).HasColumnName("last_name");
            modelBuilder.Entity<User>().Property(e => e.NTLogin).HasColumnName("nt_login");
			modelBuilder.Entity<User>().Property(e => e.ISOCode).HasColumnName("iso_code");
            #endregion

            #region UserGroup
            modelBuilder.Entity<UserGroup>()
                .ToTable("USER_GROUP_NEW")
                .Property(e => e.Id)
                .HasDatabaseGeneratedOption(DatabaseGeneratedOption.Identity)
                .HasColumnName("id");


            modelBuilder.Entity<UserGroup>()
                .HasMany(e => e.Users)
                .WithMany(e => e.UserGroups)
                .Map(m => m.ToTable("USER_GROUP_BIND_NEW").MapLeftKey("GROUP_ID").MapRightKey("USER_ID"));

            #endregion
<#
		foreach(var content in model.Contents)
		{
#>

            #region <#=content.MappedName#> mappings
            modelBuilder.Entity<<#=content.MappedName#> >()
                .ToTable(<#=content.UseDefaultFiltration ? string.Format("GetTableName(\"{0}\")", content.Id) : "\"" + content.TableName + "\""#>)
                .Property(x => x.Id)
                .HasDatabaseGeneratedOption(DatabaseGeneratedOption.Identity)
                .HasColumnName("CONTENT_ITEM_ID");
           
		    modelBuilder.Entity<<#=content.MappedName#>>()                
                .Property(x => x.LastModifiedBy)
                .HasColumnName("LAST_MODIFIED_BY");
            
            modelBuilder.Entity<<#=content.MappedName#>>()
                .Property(x => x.StatusTypeId)
                .HasColumnName("STATUS_TYPE_ID");

			modelBuilder.Entity<<#=content.MappedName#>>()
                .HasRequired<StatusType>(x => x.StatusType)
                .WithMany()
                .HasForeignKey(x => x.StatusTypeId); 

<#
            foreach (var attribute in content.Attributes.Where(x => !x.IsRelation && x.Name != x.MappedName))
            {
#>
            modelBuilder.Entity<<#=attribute.Content.MappedName#>>()
                .Property(x => x.<#=attribute.MappedName#>)
                .HasColumnName("<#=attribute.Name#>");
<#
	        }

            foreach (var attribute in content.Attributes.Where(x => x.ShouldMap && x.ExplicitMapping != null))
            {
#>
            modelBuilder.Entity<<#=attribute.Content.MappedName#>>()
                .Property(x => x.<#=attribute.MappedName#>)
                .HasColumnName("<#=attribute.ExplicitMapping#>");
<#		 
            }

            foreach (var attribute in content.Attributes.Where(x => x.IsO2M))
            {
#>
            modelBuilder.Entity<<#=attribute.Content.MappedName#>>()
                .HasOptional<<#=attribute.RelatedContent.MappedName#>>(mp => mp.<#=attribute.MappedName#>)
                .WithMany(mp => mp.<#=attribute.RelatedAttribute.MappedName#>)
                .HasForeignKey(fp => fp.<#=attribute.OriginalMappedName#>);

            modelBuilder.Entity<<#=attribute.Content.MappedName#>>()
                .Property(x => x.<#=attribute.OriginalMappedName#>)
                .HasColumnName("<#=attribute.MappedName#>");
<#		 
            }

            foreach (var attribute in content.Attributes.Where(x => x.IsM2M && x.IsSource == true))
            {
				if(!settings.UseReversedAssociations || !attribute.RelatedContent.SplitArticles)
                {
#>
            
			modelBuilder.Entity<<#=attribute.Content.MappedName#>>().HasMany<<#=attribute.RelatedContent.MappedName#>>(p => p.<#=attribute.MappedName#>)
				.WithMany(r => r.<#=attribute.RelatedAttribute.MappedName#>)
                .Map(rp =>
                {
                    rp.MapLeftKey("id");
                    rp.MapRightKey("linked_id");
                    rp.ToTable(GetLinkTableName("<#=attribute.LinkId#>"));
                });
<#
				}
				else
                {
#>

            modelBuilder.Entity<<#=attribute.Content.MappedName#>>().HasMany<<#=attribute.RelatedContent.MappedName#>>(p => p.<#=attribute.MappedName#>).WithMany()
                .Map(rp =>
                {
                    rp.MapLeftKey("id");
                    rp.MapRightKey("linked_id");
                    rp.ToTable(GetLinkTableName("<#=attribute.LinkId#>"));
                });

            modelBuilder.Entity<<#=attribute.RelatedContent.MappedName#>>().HasMany<<#=attribute.Content.MappedName#>>(p => p.<#=attribute.RelatedAttribute.MappedName#>).WithMany()
                .Map(rp =>
                { 
<#
					if(attribute.ContentId != attribute.RelatedContentId)
                    {
#>
                    rp.MapLeftKey("id"); // !+
                    rp.MapRightKey("linked_id");
<#
                    }
					else
                    {
#>
                    rp.MapLeftKey("linked_id"); // ===
                    rp.MapRightKey("id");
<#
                    }
#>
                    rp.ToTable(GetReversedLinkTableName("<#=attribute.LinkId#>"));
                });

<#                
				}
            }
#>

<#			foreach(var attribute in content.Attributes.Where(x => x.GenerateLibraryUrl)) 
		    { #>
            modelBuilder.Entity<<#=attribute.Content.MappedName#>>().Ignore(p => p.<#=attribute.MappedName#>Url);
<#			} 

  			foreach(var attribute in content.Attributes.Where(x => x.GenerateUploadPath)) 
			{
#>
            modelBuilder.Entity<<#=attribute.Content.MappedName#>>().Ignore(p => p.<#=attribute.MappedName#>UploadPath);
<#
			}#> 
            #endregion
<#
        }
#>
        }

        #region Private members
        private string GetTableName(string contentId)
        {
            switch (_contentAccess)
            {
                case ContentAccess.Live:
                    return string.Format("content_{0}_live_new", contentId);
                case ContentAccess.Stage:
                    return string.Format("content_{0}_stage_new", contentId);
                case ContentAccess.InvisibleOrArchived:
                    return string.Format("content_{0}_united_new", contentId);
            }

            throw new InvalidOperationException(_contentAccess + " is not supported.");
        }

        private string GetLinkTableName(string linkId)
        {
            switch (_contentAccess)
            {
                case ContentAccess.Live:
                    return string.Format("item_link_{0}", linkId);
                case ContentAccess.Stage:
                    return string.Format("item_link_{0}_united", linkId);
                case ContentAccess.InvisibleOrArchived:
                    return string.Format("item_link_{0}_united", linkId);
            }

            throw new InvalidOperationException(_contentAccess + " is not supported.");
        }

        private string GetReversedLinkTableName(string linkId)
        {
            switch (_contentAccess)
            {
                case ContentAccess.Live:
                    return string.Format("item_link_{0}_rev", linkId);
                case ContentAccess.Stage:
                    return string.Format("item_link_{0}_united_rev", linkId);
                case ContentAccess.InvisibleOrArchived:
                    return string.Format("item_link_{0}_united_rev", linkId);
            }

            throw new InvalidOperationException(_contentAccess + " is not supported.");
        }
        #endregion

        #region Nested type
        public enum ContentAccess
        {
            /// <summary>
            /// Published articles
            /// </summary>
            Live = 0,
            /// <summary>
            /// Splitted versions of articles
            /// </summary>
            Stage = 1,
            /// <summary>
            /// Splitted versions of articles including invisible and archived
            /// </summary>
            InvisibleOrArchived = 2
        } 
        #endregion
    }
}

<#}
if (settings.GenerateExtensions && settings.GenerateModel)
{	
   manager.StartNewFile(model.Schema.ClassName + ".Extensions.cs"); #>
// Code generated by a template
using System;
using System.Linq;
using System.Data.Entity;
using System.Data.Common;
using System.Data.Entity.Core.EntityClient;
using System.Data.Entity.Core.Objects;
using System.Data.Entity.Infrastructure;
using System.Data.SqlClient;
using Quantumart.QPublishing.Database;
<#= settings.Usings#>

namespace <#=System.Runtime.Remoting.Messaging.CallContext.LogicalGetData("NamespaceHint")#>
{
    public partial class <#= model.Schema.ClassName#>: IQPLibraryService, IQPFormService
    {
		#region Constructors

		public <#= model.Schema.ClassName#>(string connectionStringOrName)
            : base(connectionStringOrName)
        {
            this.Configuration.LazyLoadingEnabled = <#=settings.LazyLoadingEnabled.ToString().ToLower()#>;
            OnContextCreated();
        }

		public <#= model.Schema.ClassName#>(DbConnection connection, bool contextOwnsConnection)
            : base(connection, contextOwnsConnection)
        {
            this.Configuration.LazyLoadingEnabled = <#=settings.LazyLoadingEnabled.ToString().ToLower()#>;
            OnContextCreated();
        }

        public <#= model.Schema.ClassName#>(DbCompiledModel model) : base(model)
        {
            this.Configuration.LazyLoadingEnabled = <#=settings.LazyLoadingEnabled.ToString().ToLower()#>;
            OnContextCreated();
        }

        public <#= model.Schema.ClassName#>(DbConnection connection, DbCompiledModel model, bool contextOwnsConnection)
            : base(connection, model, contextOwnsConnection)
        {
            this.Configuration.LazyLoadingEnabled = <#=settings.LazyLoadingEnabled.ToString().ToLower()#>;
            OnContextCreated();
        }


		protected ObjectContext CurrentObjectContext
		{
			get 
			{
				return ((IObjectContextAdapter)this).ObjectContext;
			}
		}

		#endregion

		#region Private members
		private const string uploadPlaceholder = "<%=upload_url%>";
		private const string sitePlaceholder = "<%=site_url%>";
		private static string _defaultSiteName = "<#=model.Schema.SiteName ?? ""#>";
		private static string _defaultConnectionString;
		private static string _defaultConnectionStringName = "<#= model.Schema.ConnectionStringName#>";
		private bool _shouldRemoveSchema = false;
		private string _siteName;
		private DBConnector _cnn;
		#endregion

		#region Properties
		public static bool RemoveUploadUrlSchema = false;

		public bool ShouldRemoveSchema { get { return _shouldRemoveSchema; } set { _shouldRemoveSchema = value; } }
		public Int32 SiteId { get; private set; }
		public string SiteUrl { get { return StageSiteUrl; } }		
		public string UploadUrl { get { return <#= model.Schema.UseLongUrls ? "LongUploadUrl": "ShortUploadUrl"#>; } }		
		public string LiveSiteUrl { get; private set; }		
		public string LiveSiteUrlRel { get; private set; }		
		public string StageSiteUrl { get; private set; }		
		public string StageSiteUrlRel { get; private set; }		
		public string LongUploadUrl { get; private set; }		
		public string ShortUploadUrl { get; private set; }		
		public Int32 PublishedId { get; private set; }
		public string ConnectionString { get; private set; }
		public static string DefaultSiteName 
		{ 
			get { return _defaultSiteName; }
			set { _defaultSiteName = value; }
		}
		public DBConnector Cnn
		{
			get 
			{
				if (_cnn == null) 
				{
					_cnn = //(CurrentObjectContext.Connection != null) ? new DBConnector(((EntityConnection)CurrentObjectContext.Connection).StoreConnection) : 
					      new DBConnector(DefaultConnectionString);				
					_cnn.UpdateManyToMany = false;
				}
				return _cnn;
			}
		}
		public string SiteName 
		{ 
			get { return _siteName; } 
			set
			{
				if (!String.Equals(_siteName, value, StringComparison.InvariantCultureIgnoreCase))
				{
					_siteName = value;
					SiteId = Cnn.GetSiteId(_siteName);
					LoadSiteSpecificInfo();
				}
			}
		}
		public static string DefaultConnectionString 
		{ 
			get
			{
				if (_defaultConnectionString == null)
				{
					var obj = System.Configuration.ConfigurationManager.ConnectionStrings[_defaultConnectionStringName];
					if (obj == null)
						throw new ApplicationException(string.Format("Connection string '{0}' is not specified", _defaultConnectionStringName));
					_defaultConnectionString = obj.ConnectionString;
				}
				return _defaultConnectionString;
			}
			set
			{
				_defaultConnectionString = value;
			}
		}
		#endregion

		#region Factory methods
		public static <#= model.Schema.ClassName#> Create(SqlConnection connection)
		{
			return Create(connection, DefaultSiteName);
		}

		public static <#= model.Schema.ClassName#> Create(IMappingConfigurator configurator, SqlConnection connection, bool contextOwnsConnection)
        {
            var ctx = new <#= model.Schema.ClassName#>(connection, configurator.GetBuiltModel(connection), contextOwnsConnection);
            ctx.SiteName = DefaultSiteName;
            ctx.ConnectionString = connection.ConnectionString;
            return ctx;
        }

        public static <#= model.Schema.ClassName#> Create(IMappingConfigurator configurator, SqlConnection connection)
        {
            return Create(configurator, connection, true);
        }

        public static <#= model.Schema.ClassName#> Create(IMappingConfigurator configurator)
        {
            return Create(configurator, new SqlConnection(DefaultConnectionString), true);
        }

		public static <#= model.Schema.ClassName#> Create(string connection, string siteName) 
		{
            <#= model.Schema.ClassName#> ctx;
			if(connection.IndexOf("metadata", StringComparison.InvariantCultureIgnoreCase) == -1)
			{
				ctx = new <#= model.Schema.ClassName#>(new SqlConnection(connection), true);
				ctx.SiteName = siteName;
				ctx.ConnectionString = connection;
				return ctx;
			}

			ctx = new <#= model.Schema.ClassName#>(connection);
			ctx.SiteName = siteName;
			ctx.ConnectionString = connection;
			return ctx;
		}

		public static <#= model.Schema.ClassName#> Create(SqlConnection connection, string siteName) 
		{
			<#= model.Schema.ClassName#> ctx = new <#= model.Schema.ClassName#>(connection, false);
			ctx.SiteName = siteName;
			ctx.ConnectionString = connection.ConnectionString;
			return ctx;
		}

		public static <#= model.Schema.ClassName#> Create(string connection) 
		{
			return Create(connection, DefaultSiteName);
		}

		public static <#= model.Schema.ClassName#> Create() 
		{
			return Create(DefaultConnectionString);
		}

		#endregion

		#region Partial methods
		partial void OnObjectMaterialized(object entity);
		#endregion

		#region Helpers
		public string ReplacePlaceholders(string input)
		{
			string result = input;
			if (result != null)
			{
				result = result.Replace(uploadPlaceholder, UploadUrl);
				result = result.Replace(sitePlaceholder, SiteUrl);
			}
			return result;
		}

		public string GetUrl(string input, string className, string propertyName)
		{
            return String.Format(@"{0}/{1}", Cnn.GetUrlForFileAttribute(Cnn.GetAttributeIdByNetNames(SiteId, className, propertyName), true, ShouldRemoveSchema), input);
		}


		public string GetUploadPath(string input, string className, string propertyName)
		{
			return Cnn.GetDirectoryForFileAttribute(Cnn.GetAttributeIdByNetNames(SiteId, className, propertyName));
		}
		
		public void LoadSiteSpecificInfo()
        {
            if (RemoveUploadUrlSchema && !_shouldRemoveSchema)
            {
                _shouldRemoveSchema = RemoveUploadUrlSchema;
            }

            LiveSiteUrl = Cnn.GetSiteUrl(SiteId, true);
            LiveSiteUrlRel = Cnn.GetSiteUrlRel(SiteId, true);
            StageSiteUrl = Cnn.GetSiteUrl(SiteId, false);
            StageSiteUrlRel = Cnn.GetSiteUrlRel(SiteId, false);
            LongUploadUrl = Cnn.GetImagesUploadUrl(SiteId, false, _shouldRemoveSchema);
            ShortUploadUrl = Cnn.GetImagesUploadUrl(SiteId, true, _shouldRemoveSchema);
            PublishedId = Cnn.GetMaximumWeightStatusTypeId(SiteId);
        }
		#endregion

		partial void OnContextCreated()
		{
			this.CurrentObjectContext.ObjectMaterialized += OnObjectMaterialized;
		}

        void OnObjectMaterialized(object sender, ObjectMaterializedEventArgs e)
        {
            if (e.Entity == null)
                return;

            var entity = e.Entity;
            OnObjectMaterialized(entity);
			if(e.Entity is IQPArticle)
			{
				((IQPArticle)e.Entity).OnMaterialized(this);
			}
        }

		#region Save changes
		public override int SaveChanges()
        {
            return OnSaveChanges();
        }

        int OnSaveChanges()
        {
			base.ChangeTracker.DetectChanges();

            var objectCount = 0;
            var ctx = CurrentObjectContext;
            var manager = ctx.ObjectStateManager;

            var added = manager.GetObjectStateEntries(EntityState.Added);
            var modified = manager.GetObjectStateEntries(EntityState.Modified);
            var deleted = manager.GetObjectStateEntries(EntityState.Deleted);

            foreach (var addedItem in added)
            {
                objectCount++;
                if (!addedItem.IsRelationship)
                {
                    var entity = addedItem.Entity as IQPArticle;
					if(entity != null)
					{
                        ProcessCreating(addedItem.EntitySet.ElementType.Name, entity, addedItem);
					}
                }
                else
                {
                }
            }

            foreach (var modifiedItem in modified)
            {
                if (!modifiedItem.IsRelationship)
                {
                    objectCount++;
                    var entity = modifiedItem.Entity as IQPArticle;
                    if (entity != null)
                    {
                        ProcessUpdating(modifiedItem.EntitySet.ElementType.Name, entity, modifiedItem);
                    }
                }
                else
                {
                }
            }

            return 0;
        }


        private void ProcessCreating(string contentName, IQPArticle instance, ObjectStateEntry entry)
        {
			throw new NotImplementedException();
            var properties = entry.GetModifiedProperties().ToList();
            var values = instance.Pack(this);
            DateTime created = DateTime.Now;
            // instance.LoadStatusType();
            // todo: load first status
            const string lowestStatus = "None";
            if (!properties.Contains("Visible"))
                instance.Visible = true;
            if (!properties.Contains("Archive"))
                instance.Archive = false;

            // instance.Id = Cnn.AddFormToContent(SiteId, Cnn.GetContentIdByNetName(SiteId, contentName), lowestStatus, ref values, 0, true, 0, instance.Visible, instance.Archive, true, ref created);
            instance.Created = created;
            instance.Modified = created;
        }

		private void ProcessUpdating(string contentName, IQPArticle instance, ObjectStateEntry entry)
        {
		    throw new NotImplementedException();
		    var properties = entry.GetModifiedProperties().ToList();
<#		if(usePartialUpdate) { #>
			var values = instance.Pack(this, properties);
<#		} else { #>
			var values = instance.Pack(this);
<#		} #>
			DateTime modified = DateTime.Now;
			throw new NotImplementedException("CUD operations are not implemented yet.");
			// Cnn.AddFormToContent(SiteId, Cnn.GetContentIdByNetName(SiteId, contentName), instance.StatusType.StatusTypeName, ref values, (int)instance.Id, true, 0, instance.Visible, instance.Archive, true, ref modified);
			// instance.Modified = modified;
        }
		#endregion
		string IQPFormService.GetFormNameByNetNames(string netContentName, string netFieldName)
		{
			return Cnn.GetFormNameByNetNames(this.SiteId, netContentName, netFieldName);
		}
	}
}
<#
}
if(settings.GenerateInterface)
{	
	 manager.StartNewFile("Interfaces.cs"); #>
// Code generated by a template
using System;
using System.Collections;
using System.Data.Common;


namespace <#=System.Runtime.Remoting.Messaging.CallContext.LogicalGetData("NamespaceHint")#>
{
	///<summary>
	/// An interface for all contents
	///</summary>
	public interface IQPArticle
	{
        int Id { get; set; }
        int StatusTypeId { get; set; }
        bool Visible { get; set; }
        bool Archive { get; set; }
        DateTime Created { get; set; }
        DateTime Modified { get; set; }
        int LastModifiedBy { get; set; }
		StatusType StatusType { get; set; }

		///<summary>
		/// Method used for initialization entities after them to be loaded from database
		///</summary>
		void OnMaterialized(IQPLibraryService context);

		Hashtable Pack(IQPFormService context, params string[] propertyNames);
	}

    public interface IQPLibraryService
    {
        string GetUrl(string input, string className, string propertyName);

        string GetUploadPath(string input, string className, string propertyName);

		string ReplacePlaceholders(string text);
    }

	public interface IQPFormService
	{
		string GetFormNameByNetNames(string netContentName, string netFieldName);

		string ReplacePlaceholders(string text);
	}

}
<#
}
if(settings.GenerateMappingInterface)
{	
	 manager.StartNewFile("MappingInterfaces.cs"); #>

using System.Data.Common;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;

namespace <#=System.Runtime.Remoting.Messaging.CallContext.LogicalGetData("NamespaceHint")#>
{
	public interface IMappingConfigurator
	{
	    DbCompiledModel GetBuiltModel(DbConnection connection);
		void OnModelCreating(DbModelBuilder modelBuilder);
	}
}
<#
}
if(settings.GenerateExtensions && settings.GenerateModel)
{	
	 manager.StartNewFile("EFConnectionScope.cs"); #>
// Code generated by a template
using System;
using System.Data.Entity.Core.EntityClient;
using System.Data.Entity.Core.Metadata.Edm;
using System.Data.SqlClient;

namespace <#=System.Runtime.Remoting.Messaging.CallContext.LogicalGetData("NamespaceHint")#>
{
	public class <#= model.Schema.ClassName#>ConnectionScope
	{

	}
}
<# 
}

if(settings.GenerateClasses)
{	
#>
<# manager.StartNewFile("StatusType.cs"); #>
// Code generated by a template
using System;

namespace <#=System.Runtime.Remoting.Messaging.CallContext.LogicalGetData("NamespaceHint")#>
{   
	public partial class StatusType
    {
        public Int32 Id { get; set; }
        public string StatusTypeName { get; set; }
        public int Weight { get; set; }
        // public DateTime Created { get; set; }
        // public DateTime Modified { get; set; }
        // public bool BuiltIn { get; set; }
        public Int32 SiteId { get; set; }
    }
}

<# manager.StartNewFile("User.cs"); #>
// Code generated by a template
using System;
using System.Collections.Generic;

namespace <#=System.Runtime.Remoting.Messaging.CallContext.LogicalGetData("NamespaceHint")#>
{   
	public partial class User
    {
        public User()
        {
            UserGroups = new HashSet<UserGroup>();
        }

        public virtual int Id { get; set; }
        public virtual string login { get; set; }
        public virtual string NTLogin { get; set; }
        public virtual string ISOCode { get; set; }
        public virtual string FirstName { get; set; }
        public virtual string LastName { get; set; }
        public virtual string Email { get; set; }
        public virtual ICollection<UserGroup> UserGroups { get; set; }
    }
}

<# manager.StartNewFile("UserGroup.cs"); #>
// Code generated by a template
using System;
using System.Collections.Generic;

namespace <#=System.Runtime.Remoting.Messaging.CallContext.LogicalGetData("NamespaceHint")#>
{   
	public partial class UserGroup
    {
        public UserGroup()
        {
            Users = new HashSet<User>();
        }
        public virtual int Id { get; set; }
        public virtual string Name { get; set; }
        public virtual ICollection<User> Users { get; set; }
    }
}

<#  
	if(!settings.PlaceContentsInSeparateFiles)
    {
		 manager.StartNewFile(model.Schema.ClassName + ".Contents"+".cs");
#>
// Code generated by a template
using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
<#    
	}
	 #>
<#	foreach(var content in model.Contents) { #>	
<# 
    if(settings.PlaceContentsInSeparateFiles)
    {
		manager.StartNewFile(content.MappedName+".cs"); #>
// Code generated by a template
using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
<#
	}
#>
namespace <#=System.Runtime.Remoting.Messaging.CallContext.LogicalGetData("NamespaceHint")#>
{

	public partial class <#=content.MappedName #>: IQPArticle
	{
        public <#=content.MappedName #>()
        {
<#	   	foreach(var attribute in content.Attributes.Where(x => x.IsM2M || x.IsM2O)) { #>
		    <#=attribute.MappedName#> = new HashSet<<#=attribute.RelatedContent.MappedName#>>();
<#		} #>
        }

        public virtual Int32 Id { get; set; }
        public virtual Int32 StatusTypeId { get; set; }
        public virtual bool Visible { get; set; }
        public virtual bool Archive { get; set; }
        public virtual DateTime Created { get; set; }
        public virtual DateTime Modified { get; set; }
        public virtual Int32 LastModifiedBy { get; set; }
        public virtual StatusType StatusType { get; set; }

<#	   	foreach(var attribute in content.Attributes.Where(x => !x.IsM2M && !x.IsM2O && !x.IsO2M)) { #>
		public virtual <#= attribute.NetType#> <#=attribute.MappedName#> { get; set; }
<#		} #>
<#	   	foreach(var attribute in content.Attributes.Where(x => x.IsO2M)) { #>
		/// <summary>
		/// <#=attribute.Description??""#>
		/// </summary>			
		public virtual <#= attribute.RelatedContent.MappedName#> <#=attribute.MappedName#> { get; set; }
<#		} #>
<#	   	foreach(var attribute in content.Attributes.Where(x => x.IsO2M)) { #>
		/// <summary>
		/// <#=attribute.Description??""#>
		/// </summary>
		public virtual Int32? <#=attribute.OriginalMappedName#> { get; set; }
<#		} #>
<#	   	foreach(var attribute in content.Attributes.Where(x => x.IsM2M || x.IsM2O)) { #>
		/// <summary>
		/// <#=attribute.Description??""#>
		/// </summary>		
		public virtual ICollection<<#=attribute.RelatedContent.MappedName#>> <#=attribute.MappedName#> { get; set; }
<#		} #>
<#	    if(content.Attributes.Any(x => x.GenerateLibraryUrl || x.GenerateUploadPath || x.IsNullable)) { #>		
		#region Generated Content properties
<#	   	foreach(var attribute in content.Attributes.Where(x => x.GenerateLibraryUrl)) { #>
		// public string <#=attribute.MappedName#>Url { get; set; }
<#		} 
  		foreach(var attribute in content.Attributes.Where(x => x.GenerateUploadPath)) { #>
		// public string <#=attribute.MappedName#>UploadPath { get; set; }
<#		} 
  		foreach(var attribute in content.Attributes.Where(x => x.IsNullable)) { #>
		// public <#= attribute.ExactType#> <#=attribute.MappedName#>Exact { get { return this.<#=attribute.MappedName#> == null ? default(<#= attribute.ExactType#>) : this.<#=attribute.MappedName#>.Value; } }
<#		} #>
		#endregion
<#  } #>


	}
}
<# }#>

<# 
}   

if(settings.GenerateExtensions && settings.GenerateClasses)
{	
	manager.StartNewFile(model.Schema.ClassName+".Contents.Extensions.cs"); #>
// Code generated by a template
using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;

namespace <#=System.Runtime.Remoting.Messaging.CallContext.LogicalGetData("NamespaceHint")#>
{
<# foreach(var content in model.Contents) { #>
	public partial class <#=content.MappedName #>: IQPArticle
	{
		#region Static members
		protected static readonly Dictionary<string, Func<<#=content.MappedName #>, IQPFormService, string>> _valueExtractors = new Dictionary<string, Func<<#=content.MappedName #>,  IQPFormService, string>>
		{
<#		foreach(var attribute in content.Attributes.Where(x => !x.IsM2O && !x.IsM2M)) { #>
			{ "<#=attribute.OriginalMappedName #>", new Func<<#=content.MappedName #>, IQPFormService, string>((self, ctx) => self.<#=attribute.OriginalMappedName #> != null ? <#
			 if(attribute.Type == "DateTime" || attribute.Type == "O2M" || attribute.Type == "Numeric" || attribute.Type == "Date" || attribute.Type == "Time") { #>self.<#=attribute.OriginalMappedName #>.ToString()<# }
			 else if(attribute.Type == "Boolean") {#>self.<#=attribute.OriginalMappedName #>.Value ? "1" : "0"<#} 
			 else if(model.Schema.ReplaceUrls && (attribute.CanContainPlaceholders)) {#>ctx.ReplacePlaceholders(self.<#=attribute.OriginalMappedName #>)<# } 
			 else { #>self.<#=attribute.OriginalMappedName #><# }#> : null) },
<#		} #>
		};

		#endregion
<#	if(content.Attributes.Any(x => x.GenerateLibraryUrl || x.GenerateUploadPath || x.IsNullable)) { #>
		#region Genarated properties
<#	   	foreach(var attribute in content.Attributes.Where(x => x.GenerateLibraryUrl)) { #>
		public string <#=attribute.MappedName#>Url { get; set; }
<#		} 
  		foreach(var attribute in content.Attributes.Where(x => x.GenerateUploadPath)) { #>
		public string <#=attribute.MappedName#>UploadPath { get; set; }
<#		} 
  		foreach(var attribute in content.Attributes.Where(x => x.IsNullable)) { #>
		public <#= attribute.ExactType#> <#=attribute.MappedName#>Exact { get { return this.<#=attribute.MappedName#> == null ? default(<#= attribute.ExactType#>) : this.<#=attribute.MappedName#>.Value; } }
<#		} #>
		#endregion
<#  } #>
		#region Methods
		void IQPArticle.OnMaterialized(IQPLibraryService context)
		{
<#	if(model.Schema.ReplaceUrls) {	
		foreach(var attribute in content.Attributes.Where(x => x.CanContainPlaceholders)) { #>
			this.<#=attribute.MappedName#> = context.ReplacePlaceholders(this.<#=attribute.MappedName#>);
<#		}	
	} #>
<#	foreach(var attribute in content.Attributes.Where(x => x.GenerateLibraryUrl)) { #>
			this.<#=attribute.MappedName#>Url = context.GetUrl(this.<#=attribute.MappedName#>, "<#=content.MappedName#>", "<#= attribute.MappedName#>");
<#	} #>
<#	foreach(var attribute in content.Attributes.Where(x => x.GenerateUploadPath)) { #>
			this.<#=attribute.MappedName#>UploadPath = context.GetUploadPath(this.<#=attribute.MappedName#>, "<#=content.MappedName#>", "<#= attribute.MappedName#>");
<#	} #>
		}

		// для Poco перенести из класса куда-нибудь, так как нарушается концепция доступа к БД
		Hashtable IQPArticle.Pack(IQPFormService context, params string[] propertyNames)
        {
            Hashtable table;

            if (propertyNames == null || propertyNames.Length == 0)
            {
				// todo: filter null values
                table = new Hashtable(_valueExtractors.ToDictionary(x => context.GetFormNameByNetNames("<#=content.MappedName#>", x.Key), y => y.Value(this, context)));
            }
            else
            {
                table = new Hashtable();
                foreach (var prop in propertyNames.Join(_valueExtractors.Keys, x => x, x => x, (x, y) => x))
                {
					string value = _valueExtractors[prop](this, context);
					table.Add(prop, value);
                }
            }

            return table;
        }
		#endregion
	}
<# }#>
}
<# 
}   
   manager.Process(true); #>
<#+ 
public class Localization
{
    public bool UseSelectiveMappings { get; set; }
    public bool GenerateMappingsRuntime { get; set; }
    public bool CaseSensitive { get; set; }
    public string Pattern { get; set; }
    public Map[] CultureMappings { get; set; }

}
public class Map
{
    public string CultureAlias { get; set; }
    public string To { get; set; }
}
public class EDMXSettings
{
    public string QPContextMappingResultPath { get; set; }
    public bool GenerateModel { get; set; }
	public bool GenerateMappings { get; set; }
    public bool LazyLoadingEnabled { get; set; }
    public bool GenerateLive { get; set; }
    public bool GenerateStage { get; set; }
    public bool GenerateUnion { get; set; }
    public bool InheritTableExtensions { get; set; }

    public bool GenerateClasses { get; set; }
    public bool GenerateExtensions { get; set; }
    public bool GenerateInterface { get; set; }
	public bool GenerateMappingInterface { get; set; }
    public bool UseContextNameAsConnectionString { get; set; }
    public bool UseReversedAssociations { get; set; }
	public bool PlaceContentsInSeparateFiles { get; set; }
	public string Usings { get; set;}
    public Localization Localization { get; set; }

    public static EDMXSettings Parse(string path)
    {
        var doc = System.Xml.Linq.XDocument.Load(path);

        var result = doc.Descendants("settings").Select(x => new EDMXSettings
        {
            QPContextMappingResultPath = GetElementValue<string>(x, "QPContextMappingResultPath"),
            GenerateModel = GetElementValue<bool>(x, "GenerateModel"),
			GenerateMappings = GetElementValue<bool>(x, "GenerateMappings"),
			GenerateMappingInterface = GetElementValue<bool>(x, "GenerateMappingInterface"),
            GenerateClasses = GetElementValue<bool>(x, "GenerateClasses"),
            LazyLoadingEnabled = GetElementValue<bool>(x, "LazyLoadingEnabled"),
            GenerateStage = GetElementValue<bool>(x, "GenerateStage"),
            GenerateLive = GetElementValue<bool>(x, "GenerateLive"),
            GenerateUnion = GetElementValue<bool>(x, "GenerateUnion"),
            UseContextNameAsConnectionString = GetElementValue<bool>(x, "UseContextNameAsConnectionString"),
			Usings = GetElementValue<string>(x, "Usings") ?? "",
            InheritTableExtensions = GetElementValue<bool>(x, "InheritTableExtensions"),
            GenerateExtensions = GetElementValue<bool>(x, "GenerateExtensions"),
            GenerateInterface = GetElementValue<bool>(x, "GenerateInterface"),
			PlaceContentsInSeparateFiles = GetElementValue<bool>(x, "PlaceContentsInSeparateFiles"),
            UseReversedAssociations = GetElementValue<bool>(x, "UseReversedAssociations"),
            Localization = x.Descendants("Localization").Select(
                l => new Localization
                {
                    CaseSensitive = GetElementValue<bool>(l, "CaseSensitive"),
                    GenerateMappingsRuntime = GetElementValue<bool>(l, "GenerateMappingsRuntime"),
                    UseSelectiveMappings = GetElementValue<bool>(l, "UseSelectiveMappings"),
                    Pattern = GetElementValue<string>(l, "Pattern"),
                    CultureMappings = x.Descendants("CultureMappings").Select(
                         cm => new Map
                         {
                             CultureAlias = GetAttribute<string>(cm, "cultureAlias"),
                             To = GetAttribute<string>(cm, "to")
                         }).ToArray()
                }).FirstOrDefault()
        }).First();



        return result;
    }
}
	public class ModelReader
    {
        Dictionary<int, string> _roleHash = new Dictionary<int, string>();
        Dictionary<int, string> _roles = new Dictionary<int, string>();
        Dictionary<int, int> _rolesInContent = new Dictionary<int, int>();

        public SchemaInfo Schema;
        public List<ContentInfo> Contents;
        public List<AttributeInfo> Attributes;
        public List<LinkInfo> Links;


        public ModelReader(string path, Action<string> write, bool isStage = true)
        {
            var doc = System.Xml.Linq.XDocument.Load(path);
            Schema = doc.Descendants("schema").Select(x => new SchemaInfo
            {
                ConnectionStringName = GetAttribute<string>(x, "connectionStringName", true),
                ClassName = GetAttribute<string>(x, "class", true),
                NamespaceName = GetAttribute<string>(x, "namespace", true),
                SiteName = GetAttribute<string>(x, "siteName", true),
                UseLongUrls = GetAttribute<bool>(x, "useLongUrls"),
                ReplaceUrls = GetAttribute<bool>(x, "replaceUrls"),
                IsStageMode = isStage,//GetAttribute<bool>(x, "forStage") 
            }).First();

            Schema.SchemaNamespace = Schema.ConnectionStringName + Schema.ClassName.Replace(".", "");
            Schema.SchemaContainer = Schema.SchemaNamespace + "StoreContainer";

            Contents = doc.Descendants("schema").First().Descendants("content").Select(x => new ContentInfo
            {
                Id = GetAttribute<int>(x, "id", true),
                Name = GetAttribute<string>(x, "name", true),
                MappedName = GetAttribute<string>(x, "mapped_name", true),
                PluralMappedName = GetAttribute<string>(x, "plural_mapped_name", true),
                UseDefaultFiltration = bool.Parse(x.Attribute("use_default_filtration").Value),
                IsVirtual = GetAttribute<bool>(x, "virtual"),
				SplitArticles = GetAttribute<bool>(x, "split_articles", fallbackValue: true),
                IsStageMode = Schema.IsStageMode,
                Attributes = x.Descendants("attribute").Select(a => new AttributeInfo
                {
                    Id = GetAttribute<int>(a, "id", true),
                    Name = GetAttribute<string>(a, "name", true),
                    MappedName = GetAttribute<string>(a, "mapped_name", true),
                    MappedBackName = GetAttribute<string>(a, "mapped_back_name"),
                    Type = GetAttribute<string>(a, "type", true),
                    Size = GetAttribute<int>(a, "size"),
                    IsLong = GetAttribute<bool>(a, "is_long"),
                    RelatedContentId = GetAttribute<int>(a, "related_content_id"),
                    RelatedAttributeId = GetAttribute<int>(a, "related_attribute_id"),
                    LinkId = GetAttribute<int>(a, "link_id"),
                    ContentId = int.Parse(x.Attribute("id").Value),
                    HasM2O = GetAttribute<bool>(a, "has_m2o")
                }).ToList()
            }).ToList();

            Links = doc.Descendants("schema").First().Descendants("link").Select(x => new LinkInfo
            {
                Id = GetAttribute<int>(x, "id"),
                MappedName = GetAttribute<string>(x, "mapped_name"),
                PluralMappedName = GetAttribute<string>(x, "plural_mapped_name"),
                ContentId = GetAttribute<int>(x, "content_id"),
                LinkedContentId = GetAttribute<int>(x, "linked_content_id"),
                IsSelf = GetAttribute<bool>(x, "self"),
            }).ToList();

            Attributes = Contents.SelectMany(x => x.Attributes).ToList();

            var attributesToDelete = new List<AttributeInfo>();



            foreach (var item in Attributes.Where(x => !string.IsNullOrEmpty(x.MappedBackName) && !Attributes.Any(y => y.RelatedAttributeId == x.Id)).ToList())
            {
                if (item.RelatedContentId != 0 && !Contents.Any(x => x.Id == item.RelatedContentId))
                {
                    if (item.IsO2M)
                    {
                        item.Type = "Numeric";
                        item.ExplicitMapping = item.MappedName;
                        item.MappedName += "_ID";
                        item.ShouldMap = true;
                        item.Size = 0;
                    }
                    else
                    {
                        Attributes.RemoveAll(x => x == item);
                        var content = Contents.FirstOrDefault(x => x.Id == item.ContentId);
                        if (content == null) throw new Exception("Content not found: " + item.ContentId + " for attribute: " + item.Id);
                        content.Attributes.RemoveAll(x => x == item);
                    }

                    continue;
                }

                var newId = Attributes.Max(x => x.Id) + 1;

                var attr = new AttributeInfo
                {
                    Id = newId,
                    Name = item.MappedBackName,
                    MappedName = item.MappedBackName,
                    ContentId = item.RelatedContentId,
                    Description = string.Format("Auto-generated backing property for field (id: {0})/{1} {2}", item.Id, item.Name, item.MappedBackName),
                    RelatedAttribute = item,
                    Type = (item.Type == "O2M" ? "M2O" : "O2M")
                };


                var relatedContent = Contents.FirstOrDefault(x => x.Id == attr.ContentId);
                var c = Contents.FirstOrDefault(x => x.Id == attr.ContentId);

                if (relatedContent == null) throw new Exception("related Content not found: " + attr.ContentId + " for attribute: " + item.Id + " " + item.MappedBackName);
                if (c == null) throw new Exception("Content not found: " + attr.ContentId + " for attribute: " + item.Id + " " + item.MappedBackName);

                attr.Content = relatedContent;
                attr.RelatedContent = c;

                write(string.Format("added realted attribute  {3}/{4} ({0}) (relative to {2}) to content {1}", attr.Id, relatedContent.Id, item.Id, attr.Name, attr.MappedName));

                Attributes.Add(attr);
                relatedContent.Attributes.Add(attr);

                item.RelatedAttributeId = newId;
            }

            foreach (var item in Attributes)
            {
                item.Content = Contents.First(x => x.Id == item.ContentId);
            }

            foreach (var item in Contents.SelectMany(x => x.Attributes))
            {
                item.Content = Contents.First(x => x.Id == item.ContentId);
            }

            foreach (var item in Attributes.Where(x => x.RelatedAttributeId != 0))
            {
                write(string.Format("process {0} {1}", item.Id, item.Name));
                item.RelatedAttribute = Attributes.FirstOrDefault(x => x.Id == item.RelatedAttributeId);
                if (item.RelatedAttribute != null)
                {
                    item.RelatedAttribute.RelatedAttribute = item;

                    item.RelatedContent = item.RelatedAttribute.Content;

                    item.RelatedAttribute.RelatedContent = item.Content;
                }
            }

            var linksToRemove = new List<LinkInfo>();
            foreach (var link in Links.ToList())
            {
                var contentFrom = Contents.FirstOrDefault(x => x.Id == link.ContentId);

                if (contentFrom == null)
                {
                    linksToRemove.Add(link);
                    write(string.Format("removed link {0} with name {1}", link.Id, link.MappedName));
                    continue;
                    //throw new Exception(string.Format("Link {0} is incorrect, content {1} is not found.", link.Id, link.ContentId));
                }
                var contentTo = Contents.FirstOrDefault(x => x.Id == link.LinkedContentId);


                if (contentTo == null)
                {
                    write(string.Format("removed link {0} with name {1}", link.Id, link.MappedName));
                    linksToRemove.Add(link);
                    continue;
                }
                var attributeFrom = Attributes.FirstOrDefault(x => x.LinkId == link.Id && link.ContentId == x.ContentId);
                var attributeTo = Attributes.FirstOrDefault(x => x.LinkId == link.Id && link.LinkedContentId == x.ContentId && (attributeFrom == null || attributeFrom.Id != x.Id));


                if (attributeFrom == null)
                {
                    attributeFrom = GenM2M(contentTo, contentFrom, link, attributeTo);
                    Attributes.Add(attributeFrom);
                    contentFrom.Attributes.Add(attributeFrom);
                }

                if (attributeTo == null)
                {
                    attributeTo = GenM2M(contentFrom, contentTo, link, attributeFrom);
                    Attributes.Add(attributeTo);
                    contentTo.Attributes.Add(attributeTo);
                }

                attributeTo.RelatedAttributeId = 0;
                attributeFrom.RelatedAttributeId = attributeTo.Id;
                attributeFrom.RelatedAttribute = attributeTo;
                attributeTo.RelatedAttribute = attributeFrom;
                attributeFrom.IsSource = true;
                attributeFrom.Link = link;
                attributeFrom.Content = contentFrom;
                attributeFrom.RelatedContent = contentTo;
                attributeTo.Link = link;
                attributeTo.IsTarget = true;
                attributeTo.Content = contentTo;
                attributeTo.RelatedContent = contentFrom;

            }

            Links.RemoveAll(z => linksToRemove.Contains(z));

            // validation
            foreach (var validatingContent in Contents.ToList())
            {
                foreach (var vatr in validatingContent.Attributes.ToList())
                {
                    if ((vatr.IsM2O || vatr.IsM2M) && vatr.RelatedContent == null)
                    {
                        // удалим это поле
                        validatingContent.Attributes.Remove(vatr);
                        Attributes.Remove(vatr);
                        write(string.Format("removed attribute {0}/{1} from content {2} of type {3}", vatr.Id, vatr.Name, validatingContent.Name, vatr.Type));
                    }
                }
            }
        }

        private AttributeInfo GenM2M(ContentInfo contentFrom, ContentInfo contentTo, LinkInfo link, AttributeInfo attr)
        {
            var candidate = string.IsNullOrEmpty(attr.MappedBackName) ? ( "BackwardFor" + attr.MappedName): attr.MappedBackName;
            var count = contentTo.Attributes.Count(x => x.MappedName.StartsWith(candidate));
            var name = candidate + (count > 0? count.ToString(): "");/* contentTo.Attributes.Any(x => x.MappedName == contentFrom.PluralMappedName) ?
                (candidate + (count == 0 ? "" : count.ToString()))
                : (attr.MappedBackName ?? contentFrom.PluralMappedName);*/

            var mappedName = name;

            return new AttributeInfo
            {
                Id = Attributes.Max(x => x.Id) + 1,
                Name = name,
                Type = "M2M",
                MappedName = mappedName,
                Link = link,
                LinkId = link.Id,
                ContentId = contentTo.Id,
                Description = string.Format("Auto-generated backing property for {0}/{1}", attr.Id, attr.Name, attr.MappedBackName),
                Content = contentTo,
                RelatedContent=contentFrom,
                RelatedContentId=contentFrom.Id
            };

        }

        public bool ValidateAttribute(AttributeInfo attribute, bool throwOnError = false)
        {
            if (attribute.IsM2M || attribute.IsM2O)
            {
                var r = Attributes.FirstOrDefault(x => attribute.Id == x.RelatedAttributeId);
                if (r == null && throwOnError)
                    throw new ArgumentException(string.Format("validation: x => attribute.Id ({0}) == x.RelatedAttributeId", attribute.Id));

                return r != null;
            }

            return true;
        }

        public AttributeInfo GetSource(AttributeInfo attribute)
        {
            if (attribute == null)
                throw new ArgumentException("attribute");

            if (attribute.RelatedAttributeId != 0)
            {
                return attribute;
            }

            var r = Attributes.FirstOrDefault(x => attribute.Id == x.RelatedAttributeId);
            if (r == null)
                throw new ArgumentException(string.Format("x => attribute.Id ({0}) == x.RelatedAttributeId", attribute.Id));

            return r;
        }


        public AttributeInfo GetAnother(AttributeInfo attribute)
        {
            if (attribute == null)
                throw new ArgumentException("attribute");

            var r = Attributes.FirstOrDefault(x => attribute.Id == x.RelatedAttributeId) ?? Attributes.First(x => x.Id == attribute.RelatedAttributeId);
            return r;
        }

        public AttributeInfo GetTarget(AttributeInfo attribute)
        {
            if (attribute.RelatedAttributeId == 0)
            {
                return attribute;
            }

            var r = Attributes.FirstOrDefault(x => x.Id == attribute.RelatedAttributeId);

            if (r == null)
                throw new ArgumentException(string.Format("x => x.Id == attribute.RelatedAttributeId({0}", attribute.RelatedAttributeId));

            return r;
        }

        public string StartCast(AttributeInfo attribute)
        {
            switch (attribute.NetType)
            {
                case "Boolean": return "CAST(";
                case "Double": return "CAST(";
                default: return "     ";
            }
        }

        public string EndCast(AttributeInfo attribute)
        {
            switch (attribute.NetType)
            {
                case "Boolean": return " AS BIT)";
                case "Double": return " AS FLOAT)";
                default: return "";
            }
        }


       
    }
    public class SchemaInfo
    {
        public string ConnectionStringName { get; set; }
        public string ClassName { get; set; }
        public string NamespaceName { get; set; }
        public bool UseLongUrls { get; set; }
        public bool ReplaceUrls { get; set; }
        public bool SendNotifications { get; set; }
        public bool DbIndependent { get; set; }
        public string SiteName { get; set; }
        public bool IsPartial { get; set; }
        public string SchemaNamespace { get; set; }
        public string SchemaContainer { get; set; }
        public bool IsStageMode { get; set; }
        public bool LazyLoadingEnabled { get; set; }
    }

//    [DebuggerDisplay("{Id}: {MappedName}")]
    public class ContentInfo
    {
        public int Id { get; set; }
        public bool IsStageMode { get; set; }
        public string Name { get; set; }
        public string MappedName { get; set; }
        public string PluralMappedName { get; set; }
        public string Description { get; set; }
        public bool UseDefaultFiltration { get; set; }
        public bool IsVirtual { get; set; }
        public List<AttributeInfo> Attributes { get; set; }
        public IEnumerable<AttributeInfo> Columns { get { return Attributes.Where(x => !x.IsM2M && !x.IsM2O); } }
        public bool DoPostProcessing { get { return !SkipPostProcessing && Attributes.Any(x => x.CanContainPlaceholders); } }
        public bool SkipPostProcessing { get; set; }
		public bool SplitArticles {get; set; } 

        public string TableName
        {
            get
            {
                var name = "content_" + Id;
                if (UseDefaultFiltration)
                    name += (IsStageMode ? "_stage_new" : "_live_new");
                else
                    name += "_united_new";
                return name;
            }
        }
    }

//    [DebuggerDisplay("{Id}: {MappedName}")]
    public class AttributeInfo
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string MappedName { get; set; }
        public string MappedBackName { get; set; }
        public string Description { get; set; }
        public string Type { get; set; }
        public int Size { get; set; }
        public bool IsLong { get; set; }
        public int RelatedContentId { get; set; }
        public int RelatedAttributeId { get; set; }
        public int LinkId { get; set; }
        public int ContentId { get; set; }
        public bool HasM2O { get; set; }
        public string OriginalMappedName { get { return (Type == "O2M" && MappedName != null) ? MappedName + "_ID" : MappedName; } }
        public bool IsRelation { get { return IsO2M || IsM2M || IsM2O; } }
		public bool IsLocalization { get; set; }
        public bool IsO2M { get { return Type == "O2M"; } }
        public bool IsM2M { get { return Type == "M2M"; } }
        public bool IsM2O { get { return Type == "M2O"; } }
        public ContentInfo Content { get; set; }
        public bool GenerateLibraryUrl { get { return this.Type == "Image" || this.Type == "File" || this.Type == "Dynamic Image"; } }
        public bool GenerateUploadPath { get { return this.Type == "Image" || this.Type == "File"; } }
        public bool CanContainPlaceholders
        {
            get
            {
                return this.Type == "TextBox" || this.Type == "String" || this.Type == "VisualEdit";
            }
        }
        public bool IsNullable
        {
            get
            {
                return this.Type == "Numeric" || this.Type == "Datetime" || this.Type == "Boolean";
            }
        }

        public string NetType
        {
            get
            {
                switch (Type)
                {
                    case "Textbox":
                    case "String":
                    case "Image":
                    case "VisualEdit":
                    case "Dynamic Image":
                    case "File":
                        return "String";
                    case "Boolean": return "Boolean?";
                    case "Numeric":
                        if (IsLong && Size == 0)
                            return "Int64?";
                        if (Size == 0)
                            return "Int32?";
                        if (IsLong)
                            return "Decimal?";
                        return "Double?";
                    case "O2M":
                        return "Int32?";
                    case "DateTime": return "DateTime?";
                    case "Date": return "DateTime?";
                    case "Time": return "TimeSpan?";
                    default: throw new NotSupportedException("Type is not supported yet: " + this.Type);
                }
            }
        }
        public String ExactType
        {
            get
            {
                switch (Type)
                {
                    case "Textbox":
                    case "String":
                    case "Image":
                    case "VisualEdit":
                    case "Dynamic Image":
                    case "File":
                        return "String";
                    case "Boolean": return "Boolean";
                    case "Numeric":
                        if (IsLong && Size==0)
                            return "Int64";
                        if (Size == 0)
                            return "Int32";
                        if (IsLong)
                            return "Decimal";
                        return "Double";
                    case "O2M":
                        return "Int32";
                    case "DateTime": return "DateTime"; 
                    case "Date": return "DateTime";
                    case "Time": return "TimeSpan";
                    default: throw new NotSupportedException("Type is not supported yet: " + this.Type);
                }
            }
        }

        public ContentInfo RelatedContent { get; set; }

        public AttributeInfo RelatedAttribute { get; set; }

        public bool? IsSource { get; set; }

        public bool? IsTarget { get; set; }

        public LinkInfo Link { get; set; }
		
        public bool ShouldMap { get; set; }

        public string ExplicitMapping { get; set; }
    }

    public class LinkInfo
    {
        public int Id { get; set; }
        public string MappedName { get; set; }
        public string PluralMappedName { get; set; }
        public int ContentId { get; set; }
        public int LinkedContentId { get; set; }
        public bool IsSelf { get; set; }
    } 

	 public static T GetAttribute<T>(XElement e, string name, bool required = false, T fallbackValue = default(T))
        {
            return Util.GetAttribute<T>(e, name, required, fallbackValue);
        }

        public static T GetElementValue<T>(XElement e, string name, bool required = false)
        {
            return Util.GetElementValue<T>(e, name, required);
        }

        public string ToPascal(string input)
        {
            if (input == null) return null;

            switch (input)
            {
                case "STUB_FIELD": return "StubField";
            }

            return string.Join("", input.Split('_').Select(x => x.Trim()).Where(x => !string.IsNullOrEmpty(x))
                .Select(x => x.Length > 1 ? (x[0] + x.Substring(1).ToLower()) : x));
        }

        public static class Util
        {
            public static T GetAttribute<T>(XElement e, string name, bool required = false, T fallbackValue = default(T))
            {
                try
                {
                    var a = e.Attribute(name);
                    if (a == null || a.Value == null || a.Value == "")
                    {
                        if (required) throw new Exception("value should not be null or empty");
                        return fallbackValue;
                    }
                    if (typeof(T) == typeof(bool) && a.Value.Length == 1)
                        return (T)(object)Convert.ToBoolean(Convert.ToInt16(a.Value));

                    var converter = TypeDescriptor.GetConverter(typeof(T));
                    return (T)converter.ConvertFromInvariantString(a.Value);
                }
                catch (Exception ex)
                {
                    throw new Exception("problem with element " + name, ex);
                }
            }

            public static T GetElementValue<T>(XElement e, string name, bool required = false)
            {
                try
                {
                    var a = e.Elements().FirstOrDefault(x => x.Name == name);
                    if (a == null || a.Value == null || a.Value == "")
                    {
                        if (required) throw new Exception("value should not be null or empty");
                        return default(T);
                    }
                    if (typeof(T) == typeof(bool) && a.Value.Length == 1)
                        return (T)(object)Convert.ToBoolean(Convert.ToInt16(a.Value));

                    var converter = TypeDescriptor.GetConverter(typeof(T));
                    return (T)converter.ConvertFromInvariantString(a.Value);
                }
                catch (Exception ex)
                {
                    throw new Exception("problem with element " + name, ex);
                }
            }
        }
#>
<#+

// Manager class records the various blocks so it can split them up
class Manager {
    private class Block {
        public String Name;
        public int Start, Length;
    }

    private Block currentBlock;
    private List<Block> files = new List<Block>();
    private Block footer = new Block();
    private Block header = new Block();
    private ITextTemplatingEngineHost host;
    private StringBuilder template;
    protected List<String> generatedFileNames = new List<String>();

    public static Manager Create(ITextTemplatingEngineHost host, StringBuilder template) {
        return (host is IServiceProvider) ? new VSManager(host, template) : new Manager(host, template);
    }

    public void StartNewFile(String name) {
        if (name == null)
            throw new ArgumentNullException("name");
        CurrentBlock = new Block { Name = name };
    }

    public void StartFooter() {
        CurrentBlock = footer;
    }

    public void StartHeader() {
        CurrentBlock = header;
    }

    public void EndBlock() {
        if (CurrentBlock == null)
            return;
        CurrentBlock.Length = template.Length - CurrentBlock.Start;
        if (CurrentBlock != header && CurrentBlock != footer)
            files.Add(CurrentBlock);
        currentBlock = null;
    }

    public virtual void Process(bool split) {
        if (split) {
            EndBlock();
            String headerText = template.ToString(header.Start, header.Length);
            String footerText = template.ToString(footer.Start, footer.Length);
            String outputPath = Path.GetDirectoryName(host.TemplateFile);
            files.Reverse();
            foreach(Block block in files) {
                String fileName = Path.Combine(outputPath, block.Name);
                String content = headerText + template.ToString(block.Start, block.Length) + footerText;
                generatedFileNames.Add(fileName);
                CreateFile(fileName, content);
                template.Remove(block.Start, block.Length);
            }
        }
    }

    protected virtual void CreateFile(String fileName, String content) {
        if (IsFileContentDifferent(fileName, content))
            File.WriteAllText(fileName, content);
    }

    public virtual String GetCustomToolNamespace(String fileName) {
        return null;
    }

    public virtual String DefaultProjectNamespace {
        get { return null; }
    }

    protected bool IsFileContentDifferent(String fileName, String newContent) {
        return !(File.Exists(fileName) && File.ReadAllText(fileName) == newContent);
    }

    private Manager(ITextTemplatingEngineHost host, StringBuilder template) {
        this.host = host;
        this.template = template;
    }

    private Block CurrentBlock {
        get { return currentBlock; }
        set {
            if (CurrentBlock != null)
                EndBlock();
            if (value != null)
                value.Start = template.Length;
            currentBlock = value;
        }
    }

    private class VSManager: Manager {
        private EnvDTE.ProjectItem templateProjectItem;
        private EnvDTE.DTE dte;
        private Action<String> checkOutAction;
        private Action<IEnumerable<String>> projectSyncAction;

        public override String DefaultProjectNamespace {
            get {
                return templateProjectItem.ContainingProject.Properties.Item("DefaultNamespace").Value.ToString();
            }
        }

        public override String GetCustomToolNamespace(string fileName) {
            return dte.Solution.FindProjectItem(fileName).Properties.Item("CustomToolNamespace").Value.ToString();
        }

        public override void Process(bool split) {
            if (templateProjectItem.ProjectItems == null)
                return;
            base.Process(split);
            projectSyncAction.EndInvoke(projectSyncAction.BeginInvoke(generatedFileNames, null, null));
        }

        protected override void CreateFile(String fileName, String content) {
            if (IsFileContentDifferent(fileName, content)) {
                CheckoutFileIfRequired(fileName);
                File.WriteAllText(fileName, content);
            }
        }

        internal VSManager(ITextTemplatingEngineHost host, StringBuilder template)
            : base(host, template) {
            var hostServiceProvider = (IServiceProvider) host;
            if (hostServiceProvider == null)
                throw new ArgumentNullException("Could not obtain IServiceProvider");
            dte = (EnvDTE.DTE) hostServiceProvider.GetService(typeof(EnvDTE.DTE));
            if (dte == null)
                throw new ArgumentNullException("Could not obtain DTE from host");
            templateProjectItem = dte.Solution.FindProjectItem(host.TemplateFile);
            checkOutAction = (String fileName) => dte.SourceControl.CheckOutItem(fileName);
            projectSyncAction = (IEnumerable<String> keepFileNames) => ProjectSync(templateProjectItem, keepFileNames);
        }

        private static void ProjectSync(EnvDTE.ProjectItem templateProjectItem, IEnumerable<String> keepFileNames) {
            var keepFileNameSet = new HashSet<String>(keepFileNames);
            var projectFiles = new Dictionary<String, EnvDTE.ProjectItem>();
            var originalFilePrefix = Path.GetFileNameWithoutExtension(templateProjectItem.get_FileNames(0)) + ".";
            foreach(EnvDTE.ProjectItem projectItem in templateProjectItem.ProjectItems)
                projectFiles.Add(projectItem.get_FileNames(0), projectItem);

            // Remove unused items from the project
            foreach(var pair in projectFiles)
                if (!keepFileNames.Contains(pair.Key) && !(Path.GetFileNameWithoutExtension(pair.Key) + ".").StartsWith(originalFilePrefix))
                    pair.Value.Delete();

            // Add missing files to the project
            foreach(String fileName in keepFileNameSet)
                if (!projectFiles.ContainsKey(fileName))
                    templateProjectItem.ProjectItems.AddFromFile(fileName);
        }

        private void CheckoutFileIfRequired(String fileName) {
            var sc = dte.SourceControl;
            if (sc != null && sc.IsItemUnderSCC(fileName) && !sc.IsItemCheckedOut(fileName))
                checkOutAction.EndInvoke(checkOutAction.BeginInvoke(fileName, null, null));
        }
    }
} #>