<#@ IntelliSenseLanguage processor="tangibleT4Editor" language="C#" #>
<#+ void AddModelMappingConfigurator(GenerationContext context){
var model = context.Model;
var settings = context.Settings;
#>
using System;
using System.Collections.Concurrent;
using System.ComponentModel.DataAnnotations.Schema;
using System.Data.Common;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Threading;
<#= settings.Usings#>

namespace <#=System.Runtime.Remoting.Messaging.CallContext.LogicalGetData("NamespaceHint")#>
{
    public class <#=model.Schema.ClassName#>MappingConfigurator : IMappingConfigurator
    {
	    public static ContentAccess DefaultContentAccess = ContentAccess.Live;
        private ContentAccess _contentAccess;
		private static ConcurrentDictionary<ContentAccess, Lazy<DbCompiledModel>> _cache = new ConcurrentDictionary<ContentAccess, Lazy<DbCompiledModel>>();

        public <#=model.Schema.ClassName#>MappingConfigurator()
            : this(DefaultContentAccess)
        { }


        public <#=model.Schema.ClassName#>MappingConfigurator(ContentAccess contentAccess)
        {
            _contentAccess = contentAccess;
        }

        public virtual DbCompiledModel GetBuiltModel(DbConnection connection)
        {           
            return _cache.GetOrAdd(_contentAccess, a =>
            {
                var builder = new DbModelBuilder();
                OnModelCreating(builder);
                var builtModel = builder.Build(connection);

                return new Lazy<DbCompiledModel>( 
                    () => builtModel.Compile(), 
                    LazyThreadSafetyMode.ExecutionAndPublication);
            }).Value;
        }


        public virtual void OnModelCreating(DbModelBuilder modelBuilder)
        {

            #region StatusType
            modelBuilder.Entity<StatusType>()
                .ToTable("STATUS_TYPE_NEW")
                .Property(x => x.Id)
                .HasDatabaseGeneratedOption(DatabaseGeneratedOption.Identity)
                .HasColumnName("id");

            modelBuilder.Entity<StatusType>().Property(e => e.SiteId).HasColumnName("site_id");
            modelBuilder.Entity<StatusType>().Property(e => e.StatusTypeName).HasColumnName("name");
            modelBuilder.Entity<StatusType>().Property(e => e.Weight).HasColumnName("weight");
            #endregion

            #region User
            modelBuilder.Entity<User>()
                .ToTable("USER_NEW")
                .Property(e => e.Id)
                .HasDatabaseGeneratedOption(DatabaseGeneratedOption.Identity)
                .HasColumnName("id");

            modelBuilder.Entity<User>().Property(e => e.FirstName).HasColumnName("first_name");
            modelBuilder.Entity<User>().Property(e => e.LastName).HasColumnName("last_name");
            modelBuilder.Entity<User>().Property(e => e.NTLogin).HasColumnName("nt_login");
			modelBuilder.Entity<User>().Property(e => e.ISOCode).HasColumnName("iso_code");
            #endregion

            #region UserGroup
            modelBuilder.Entity<UserGroup>()
                .ToTable("USER_GROUP_NEW")
                .Property(e => e.Id)
                .HasDatabaseGeneratedOption(DatabaseGeneratedOption.Identity)
                .HasColumnName("id");


            modelBuilder.Entity<UserGroup>()
                .HasMany(e => e.Users)
                .WithMany(e => e.UserGroups)
                .Map(m => m.ToTable("USER_GROUP_BIND_NEW").MapLeftKey("GROUP_ID").MapRightKey("USER_ID"));

            #endregion
<#+
		foreach(var content in model.Contents)
		{
#>

            #region <#=content.MappedName#> mappings
            modelBuilder.Entity<<#=content.MappedName#> >()
                .ToTable(<#=content.UseDefaultFiltration ? string.Format("GetTableName(\"{0}\")", content.Id) : "\"" + content.TableName + "\""#>)
                .Property(x => x.Id)
                .HasDatabaseGeneratedOption(DatabaseGeneratedOption.Identity)
                .HasColumnName("CONTENT_ITEM_ID");
           
		    modelBuilder.Entity<<#=content.MappedName#>>()                
                .Property(x => x.LastModifiedBy)
                .HasColumnName("LAST_MODIFIED_BY");
            
            modelBuilder.Entity<<#=content.MappedName#>>()
                .Property(x => x.StatusTypeId)
                .HasColumnName("STATUS_TYPE_ID");

			modelBuilder.Entity<<#=content.MappedName#>>()
                .HasRequired<StatusType>(x => x.StatusType)
                .WithMany()
                .HasForeignKey(x => x.StatusTypeId); 

<#+
            foreach (var attribute in content.Attributes.Where(x => !x.IsRelation && x.Name != x.MappedName))
            {
#>
            modelBuilder.Entity<<#=attribute.Content.MappedName#>>()
                .Property(x => x.<#=attribute.MappedName#>)
                .HasColumnName("<#=attribute.Name#>");
<#+
	        }

            foreach (var attribute in content.Attributes.Where(x => x.ShouldMap && x.ExplicitMapping != null))
            {
#>
            modelBuilder.Entity<<#=attribute.Content.MappedName#>>()
                .Property(x => x.<#=attribute.MappedName#>)
                .HasColumnName("<#=attribute.ExplicitMapping#>");
<#+
            }

            foreach (var attribute in content.Attributes.Where(x => x.IsO2M))
            {
#>
            modelBuilder.Entity<<#=attribute.Content.MappedName#>>()
                .HasOptional<<#=attribute.RelatedContent.MappedName#>>(mp => mp.<#=attribute.MappedName#>)
                .WithMany(mp => mp.<#=attribute.RelatedAttribute.MappedName#>)
                .HasForeignKey(fp => fp.<#=attribute.OriginalMappedName#>);

            modelBuilder.Entity<<#=attribute.Content.MappedName#>>()
                .Property(x => x.<#=attribute.OriginalMappedName#>)
                .HasColumnName("<#=attribute.MappedName#>");
<#+
            }

            foreach (var attribute in content.Attributes.Where(x => x.IsM2M && x.IsSource == true))
            {
				if(!settings.UseReversedAssociations || !attribute.RelatedContent.SplitArticles)
                {
#>
            
			modelBuilder.Entity<<#=attribute.Content.MappedName#>>().HasMany<<#=attribute.RelatedContent.MappedName#>>(p => p.<#=attribute.MappedName#>)
				.WithMany(r => r.<#=attribute.RelatedAttribute.MappedName#>)
                .Map(rp =>
                {
                    rp.MapLeftKey("id");
                    rp.MapRightKey("linked_id");
                    rp.ToTable(GetLinkTableName("<#=attribute.LinkId#>"));
                });
<#+
				}
				else
                {
#>

            modelBuilder.Entity<<#=attribute.Content.MappedName#>>().HasMany<<#=attribute.RelatedContent.MappedName#>>(p => p.<#=attribute.MappedName#>).WithMany()
                .Map(rp =>
                {
                    rp.MapLeftKey("id");
                    rp.MapRightKey("linked_id");
                    rp.ToTable(GetLinkTableName("<#=attribute.LinkId#>"));
                });

            modelBuilder.Entity<<#=attribute.RelatedContent.MappedName#>>().HasMany<<#=attribute.Content.MappedName#>>(p => p.<#=attribute.RelatedAttribute.MappedName#>).WithMany()
                .Map(rp =>
                { 
<#+
					if(attribute.ContentId != attribute.RelatedContentId)
                    {
#>
                    rp.MapLeftKey("id"); // !+
                    rp.MapRightKey("linked_id");
<#+
                    }
					else
                    {
#>
                    rp.MapLeftKey("linked_id"); // ===
                    rp.MapRightKey("id");
<#+
                    }
#>
                    rp.ToTable(GetReversedLinkTableName("<#=attribute.LinkId#>"));
                });

<#+
				}
            }
#>

<#+			foreach(var attribute in content.Attributes.Where(x => x.GenerateLibraryUrl)) 
		    { #>
            modelBuilder.Entity<<#=attribute.Content.MappedName#>>().Ignore(p => p.<#=attribute.MappedName#>Url);
<#+			} 

  			foreach(var attribute in content.Attributes.Where(x => x.GenerateUploadPath)) 
			{
#>
            modelBuilder.Entity<<#=attribute.Content.MappedName#>>().Ignore(p => p.<#=attribute.MappedName#>UploadPath);
<#+
			}#> 
            #endregion
<#+
        }
#>
        }

        #region Private members
        private string GetTableName(string contentId)
        {
            switch (_contentAccess)
            {
                case ContentAccess.Live:
                    return string.Format("content_{0}_live_new", contentId);
                case ContentAccess.Stage:
                    return string.Format("content_{0}_stage_new", contentId);
                case ContentAccess.InvisibleOrArchived:
                    return string.Format("content_{0}_united_new", contentId);
            }

            throw new InvalidOperationException(_contentAccess + " is not supported.");
        }

        private string GetLinkTableName(string linkId)
        {
            switch (_contentAccess)
            {
                case ContentAccess.Live:
                    return string.Format("item_link_{0}", linkId);
                case ContentAccess.Stage:
                    return string.Format("item_link_{0}_united", linkId);
                case ContentAccess.InvisibleOrArchived:
                    return string.Format("item_link_{0}_united", linkId);
            }

            throw new InvalidOperationException(_contentAccess + " is not supported.");
        }

        private string GetReversedLinkTableName(string linkId)
        {
            switch (_contentAccess)
            {
                case ContentAccess.Live:
                    return string.Format("item_link_{0}_rev", linkId);
                case ContentAccess.Stage:
                    return string.Format("item_link_{0}_united_rev", linkId);
                case ContentAccess.InvisibleOrArchived:
                    return string.Format("item_link_{0}_united_rev", linkId);
            }

            throw new InvalidOperationException(_contentAccess + " is not supported.");
        }
        #endregion

        #region Nested type
        public enum ContentAccess
        {
            /// <summary>
            /// Published articles
            /// </summary>
            Live = 0,
            /// <summary>
            /// Splitted versions of articles
            /// </summary>
            Stage = 1,
            /// <summary>
            /// Splitted versions of articles including invisible and archived
            /// </summary>
            InvisibleOrArchived = 2
        } 
        #endregion
    }
}
<#+}#>